//
//  ClinkFrwAPI.hpp
//  clinkFrwAPI
//


#ifndef ClinkFrwAPI_hpp
#define ClinkFrwAPI_hpp

#include <stdio.h>

/**
设置是否自动更换冲突的端口(本函数要在clinkStart前先调用才有效)
val：0表示不自动更换、1表示当该端口冲突时自动更换成新的端口。
如果设成1，sdk先尝试用转发规则里配置的端口进行侦听，如果该端口已被其它程序占用，将随机生成一个可用的新端口进行侦听，所以在连接时要先通过dunGetCurrentTCPPort或dunGetCurrentTCPPort获取当前对应的新端口，再使用这个新端口来连接
*/
void dunSetAutoChangePort(int val);

/**
启动(只需要调用一次，重复调用也不会出错，调用时内部会判断是否已启动过，如果已启动过直接返回第一次调用的结果。调用时因客户端网络不通返回了0，过了段时间网络正常后我们会自动重连，这时再调用会返回150，这时如果没有调用业务也可正常运行)
key：sdk配置密钥
返回150表示成功，其它的值均为失败。150：成功、0：网络不通、1：已外部停止(如调用了停止函数，该函数一般不需要调用)、2：已内部停止(如运行过程中密钥被删除等)、170：实例到期或密钥不存在
*/
int clinkStart(const char * key);

/**
获取客户端IP(转发规则中“获取IP方式”无论设成什么，这个接口都是有效的，这个是在客户端获取的，转发规则是给你的服务器端获取的，两个没有关系，只是获取到的客户端IP都是一样的)
返回的是无符号32位小字头整数IP值，通过其它函数可转成字符串格式的IP，返回0说明盾未启动或未启动成功
*/
unsigned int dunGetClientIP32();

/**
获取客户端IP，(转发规则中“获取IP方式”无论设成什么，这个接口都是有效的，这个是在客户端获取的，转发规则是给你的服务器端获取的，两个没有关系，只是获取到的客户端IP都是一样的)。有个别语言不支持无符号32位整数所以返回64位的
返回的是有符号64位小字头整数IP值，通过其它函数可转成字符串格式的IP，返回0说明盾未启动或未启动成功
*/
long long dunGetClientIP();

/**
获取当前tcp对应端口(使用本接口前题条件：在盾启动前先调用dunSetAutoChangePort(1)将盾设置成端口冲突时自动更换新的端口，这样调用这个本接口才有意义)
ip：转发规则中的客户连接IP，也就是127开头的IP
port：转发规则中的客户连接端口
返回：如果传入的端口没有冲突或转发规则不存在返回的将和传入的端口一样，如果有冲突返回的是改变后的新端口
*/
int dunGetCurrentTCPPort(const char* ip, int port);

/**
获取当前udp对应端口(使用本接口前题条件：在盾启动前先调用dunSetAutoChangePort(1)将盾设置成端口冲突时自动更换新的端口，这样调用这个本接口才有意义)
ip：转发规则中的客户连接IP，也就是127开头的IP
port：转发规则中的客户连接端口
返回：如果传入的端口没有冲突或转发规则不存在返回的将和传入的端口一样，如果有冲突返回的是改变后的新端口
*/
int dunGetCurrentUDPPort(const char*  ip, int port);




/**
获取当前运行状态(一般不需要调用，用来在出现问题时定位问题用)
返回：0：未启动、1：已外部停止、2：已内部停止、3：启动过程中、4：启动失败、150：运行成功、170：实例到期或密钥不存在
*/
int dunGetRunState();

/**
 停止客户端安全接入组件(一般不需要调用) 注意：停止后只有进程重启后才可以再重新调用clinkStart函数，否则就算重新调用了clinkStart应用也无法连接，如果未调用clinkStart就直接调用本函数将会出错
 返回0表示成功，其它的为失败
 */
int clinkStop();

#endif /* ClinkFrwAPI_hpp */
